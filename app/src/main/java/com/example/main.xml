<?xml version="1.0" encoding="UTF-8" ?>
<directory name="main" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\">
  <file name="AddFlashcardActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\AddFlashcardActivity.java">
    <[CDATA[
// File: AddFlashcardActivity.java
package com.example.flashcardapp.main;

import android.os.Bundle;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;

import androidx.appcompat.app.AppCompatActivity;

public class AddFlashcardActivity extends AppCompatActivity {

    private EditText etQuestion, etAnswer;
    private Button btnSave;
    private FlashcardDAO flashcardDAO;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_add_flashcard);

        etQuestion = findViewById(R.id.et_question);
        etAnswer = findViewById(R.id.et_answer);
        btnSave = findViewById(R.id.btn_save);

        flashcardDAO = new FlashcardDAO(this);
        flashcardDAO.open();

        btnSave.setOnClickListener(v -> {
            String question = etQuestion.getText().toString().trim();
            String answer = etAnswer.getText().toString().trim();

            if (!question.isEmpty() && !answer.isEmpty()) {
                Flashcard flashcard = new Flashcard(question, answer);
                flashcardDAO.createFlashcard(flashcard);
                Toast.makeText(this, "Flashcard saved!", Toast.LENGTH_SHORT).show();
                finish();
            } else {
                Toast.makeText(this, "Please enter both question and answer.", Toast.LENGTH_SHORT).show();
            }
        });
    }

    @Override
    protected void onDestroy() {
        flashcardDAO.close();
        super.onDestroy();
    }
}
    ]]>
  </file>
  <file name="ChatGPTActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\ChatGPTActivity.java">
    <[CDATA[
package com.example.flashcardapp.main;

import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;

import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class ChatGPTActivity extends AppCompatActivity {

    private EditText etPrompt, etTopic, etInformativeText;
    private Button btnAccept, btnBack;
    private RecyclerView rvGeneratedQuestions;

    private boolean buildMode = true; // Set to true for using local JSON, false for real GPT requests

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_chat_gpt);

        // Initialize views
        etPrompt = findViewById(R.id.et_prompt);
        etTopic = findViewById(R.id.et_topic);
        etInformativeText = findViewById(R.id.et_informative_text);
        btnAccept = findViewById(R.id.btn_accept);
        btnBack = findViewById(R.id.btn_back);
        rvGeneratedQuestions = findViewById(R.id.rv_questions);

        rvGeneratedQuestions.setLayoutManager(new LinearLayoutManager(this));

        // Set initial view state
        btnBack.setVisibility(View.GONE);
        btnAccept.setText("Submit");
        btnAccept.setOnClickListener(v -> handleSubmit());

        // Back button returns to prompt entry
        btnBack.setOnClickListener(v -> resetToPromptView());
    }

    private void handleSubmit() {
        if (buildMode) {
            String localJson = loadLocalJson();
            if (localJson != null) {
                displayResponse(localJson); // Use local JSON for display
            } else {
                Toast.makeText(this, "Failed to load local JSON", Toast.LENGTH_SHORT).show();
            }
        } else {
            handleRealSubmit(); // Call GPT in real mode
        }
    }

    private void handleRealSubmit() {
        String userInput = etPrompt.getText().toString().trim();
        if (!userInput.isEmpty()) {
            ChatGPTHelper.getContextForQuestion(userInput, this, new ChatGPTHelper.OnChatGPTResponse() {
                @Override
                public void onSuccess(String response) {
                    displayResponse(response);
                }

                @Override
                public void onFailure(String error) {
                    runOnUiThread(() -> {
                        etInformativeText.setText("Failed to connect to GPT: " + error);
                        Toast.makeText(ChatGPTActivity.this, "Failed to connect to GPT", Toast.LENGTH_SHORT).show();
                    });
                }
            });
            etPrompt.setVisibility(View.GONE);
            btnAccept.setText("Accept");
            btnBack.setVisibility(View.VISIBLE);
        } else {
            Toast.makeText(this, "Please enter a query", Toast.LENGTH_SHORT).show();
        }
    }

    private void displayResponse(String response) {
        try {
            JSONObject parsedContent = new JSONObject(response);

            etTopic.setText(parsedContent.optString("title", "No title"));
            etInformativeText.setText(parsedContent.optString("informative_text", "No informative text"));

            JSONArray questionsArray = parsedContent.optJSONArray("questions");
            if (questionsArray != null) {
                List<Flashcard> flashcards = new ArrayList<>();
                for (int i = 0; i < questionsArray.length(); i++) {
                    JSONObject questionObject = questionsArray.getJSONObject(i);
                    Flashcard flashcard = new Flashcard();
                    flashcard.setQuestion(questionObject.optString("question"));
                    flashcard.setAnswer(questionObject.optString("answer"));
                    flashcard.setSearchTerm(questionObject.optString("searchTerm"));
                    flashcard.setUserNote(questionObject.optString("userNote"));

                    flashcards.add(flashcard);
                }

                // Populate the RecyclerView
                ChatGPTQuestionAdapter adapter = new ChatGPTQuestionAdapter(new ArrayList<>(), (flashcard, position) -> {
                     Toast.makeText(this, "Recreate clicked at position: " + position, Toast.LENGTH_SHORT).show();
                });
                rvGeneratedQuestions.setLayoutManager(new LinearLayoutManager(this));
                rvGeneratedQuestions.setAdapter(adapter);
            }
        } catch (Exception e) {
            etInformativeText.setText("Error parsing response");
            Log.e("ChatGPTActivity", "Error parsing JSON response", e);
        }
    }

    private String loadLocalJson() {
        StringBuilder jsonBuilder = new StringBuilder();
        try (InputStream is = getResources().openRawResource(R.raw.sample_response);
             BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {
            String line;
            while ((line = reader.readLine()) != null) {
                jsonBuilder.append(line);
            }
            return jsonBuilder.toString();
        } catch (IOException e) {
            Log.e("ChatGPTActivity", "Error loading JSON from raw resource", e);
            return null;
        }
    }

    private void resetToPromptView() {
        etPrompt.setVisibility(View.VISIBLE);
        btnAccept.setText("Submit");
        btnBack.setVisibility(View.GONE);
    }
}
    ]]>
  </file>
  <file name="ChatGPTHelper.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\ChatGPTHelper.java">
    <[CDATA[
package com.example.flashcardapp.main;

import android.content.Context;
import android.content.Intent;
import android.content.res.AssetManager;
import android.util.Log;
import okhttp3.*;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class ChatGPTHelper {

    private static final String API_URL = "https://api.openai.com/v1/chat/completions";
    private static String API_KEY;

    private static void initializeApiKey(Context context) {
        if (API_KEY == null) {
            try {
                AssetManager assetManager = context.getAssets();
                InputStream inputStream = assetManager.open("config.properties");
                Properties properties = new Properties();
                properties.load(inputStream);
                API_KEY = properties.getProperty("API_KEY");
            } catch (IOException e) {
                Log.e("ChatGPTHelper", "Error loading API key: " + e.getMessage());
            }
        }
    }

    private static final OkHttpClient client = new OkHttpClient.Builder()
            .connectTimeout(30, java.util.concurrent.TimeUnit.SECONDS)

            .writeTimeout(30, java.util.concurrent.TimeUnit.SECONDS)
            .readTimeout(30, java.util.concurrent.TimeUnit.SECONDS)
            .build();

    // Callback interfaces
    public interface OnChatGPTResponse {
        void onSuccess(String response);
        void onFailure(String error);
    }

    // General ChatGPT Request Method
    public static void makeChatGPTRequest(String prompt, OnChatGPTResponse callback, Context context) {

        initializeApiKey(context);

        try {
            // Create JSON request body
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("model", "gpt-4-turbo");

            JSONArray messagesArray = new JSONArray();
            JSONObject messageObject = new JSONObject();
            messageObject.put("role", "user");
            messageObject.put("content", prompt);
            messagesArray.put(messageObject);

            jsonObject.put("messages", messagesArray);
            String json = jsonObject.toString();

            // Build request
            RequestBody body = RequestBody.create(json, MediaType.get("application/json; charset=utf-8"));
            Request request = new Request.Builder()
                    .url(API_URL)
                    .header("Authorization", "Bearer " + API_KEY)
                    .post(body)
                    .build();

            // Send request asynchronously
            client.newCall(request).enqueue(new Callback() {

                @Override
                public void onFailure(Call call, IOException e) {
                    callback.onFailure("Failed to connect to GPT: " + e.getMessage());
                }

                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    if (response.isSuccessful()) {
                        String responseBody = response.body().string();
                        callback.onSuccess(responseBody);
                    } else {
                        callback.onFailure("Error: " + response.code());
                    }
                    response.close();
                }
            });

        } catch (Exception e) {
            callback.onFailure("Error constructing JSON payload: " + e.getMessage());
        }
    }

    public static void generateMultipleQuestions(String prompt, Context context, OnChatGPTResponse callback) {

        makeChatGPTRequest(prompt, new OnChatGPTResponse() {
            @Override
            public void onSuccess(String response) {
                try {
                    // Parse the response as an array of questions
                    JSONArray jsonArray = new JSONArray(response);
                    callback.onSuccess(jsonArray.toString());
                } catch (Exception e) {
                    callback.onFailure("Error parsing JSON response: " + e.getMessage());
                    Log.e("ChatGPTHelper", "Error parsing JSON response", e);
                }
            }

            @Override
            public void onFailure(String error) {
                callback.onFailure(error);
            }
        }, context);
    }

    // Specific method for getting context for a question
    public static void getContextForQuestion(String question,Context context,  OnChatGPTResponse callback) {
        String prompt = "Explain why this was important, starting with the most significant reason. Write a 150-word answer with the most important reason in the first sentence, followed by a new line after that sentence. Important: Do NOT repeat details from the question or the answer! Include one additional relevant fact in the explanation.  " + question;
        makeChatGPTRequest(prompt, new OnChatGPTResponse() {
            @Override
            public void onSuccess(String response) {
                try {
                    // Log the response to confirm its structure
                    Log.d("ChatGPT Response", "Full response: " + response);

                    // Parse the JSON response to get the "content" field directly
                    JSONObject jsonResponse = new JSONObject(response);
                    String content = jsonResponse
                            .getJSONArray("choices")
                            .getJSONObject(0)
                            .getJSONObject("message")
                            .getString("content");

                    // Display the content directly as the context
                    callback.onSuccess(content);  // Pass the content back to the calling activity or component
                } catch (Exception e) {
                    callback.onFailure("Error parsing JSON response: " + e.getMessage());
                    Log.e("ChatGPTHelper", "Error parsing JSON response", e);
                }
            }
            @Override
            public void onFailure(String error) {
                callback.onFailure(error);
            }
        },context);
    }




    // Specific method for generating a related question
    public static void generateRelatedQuestion(String question, OnChatGPTResponse callback, Context context) {
        String prompt = "Generate a related question for the following: \"" + question + "\". " +
                "Provide the response in a JSON array with the following format: " +
                "[{\"question\": \"<new question>\", \"answer\": \"<corresponding answer>\", \"searchTerm\": \"<related search term>\", " +
                "\"userNote\": \"<a note about the question>\", \"topics\": [\"<topic1>\", \"<topic2>\"]}]. " +
                "Ensure the JSON array contains only one question and is valid.";
        makeChatGPTRequest(prompt, new OnChatGPTResponse() {
            @Override
            public void onSuccess(String response) {
                // Pass the response (generated question) to EditQuestionActivity
                Intent intent = new Intent(context, EditFlashcardActivity.class);
                intent.putExtra("generated_question", response);  // Add response to intent
                context.startActivity(intent);
            }
            @Override
            public void onFailure(String error) {
                callback.onFailure(error);
            }
        }, context);
    }

}
    ]]>
  </file>
  <file name="ChatGPTQuestionAdapter.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\ChatGPTQuestionAdapter.java">
    <[CDATA[
package com.example.flashcardapp.main;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.EditText;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;

import java.util.ArrayList;
import java.util.List;

public class ChatGPTQuestionAdapter extends RecyclerView.Adapter<ChatGPTQuestionAdapter.QuestionViewHolder> {

    private final List<Flashcard> flashcards;
    private final List<Boolean> selectionStates; // Tracks selection states for each flashcard
    private OnRecreateClickListener recreateClickListener;

    public ChatGPTQuestionAdapter(List<Flashcard> flashcards, OnRecreateClickListener recreateClickListener) {
        this.flashcards = flashcards != null ? flashcards : new ArrayList<>();
        this.selectionStates = new ArrayList<>();
        for (int i = 0; i < this.flashcards.size(); i++) {
            this.selectionStates.add(false); // Initialize all as unselected
        }
        this.recreateClickListener = recreateClickListener;
    }

    @NonNull
    @Override
    public QuestionViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_generated_question, parent, false);
        return new QuestionViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull QuestionViewHolder holder, int position) {
        Flashcard flashcard = flashcards.get(position);

        holder.etQuestion.setText(flashcard.getQuestion());
        holder.etAnswer.setText(flashcard.getAnswer());

        // Prevent triggering the listener during binding
        holder.cbSelect.setOnCheckedChangeListener(null);

        // Set the current checkbox state
        holder.cbSelect.setChecked(selectionStates.get(position));

        // Add a listener to update the selection state
        holder.cbSelect.setOnCheckedChangeListener((buttonView, isChecked) -> {
            selectionStates.set(position, isChecked); // Update selectionStates
        });

        // Optional: Add a listener for recreating a flashcard if needed
        holder.itemView.setOnClickListener(v -> {
            if (recreateClickListener != null) {
                recreateClickListener.onRecreateClick(flashcard, position); // Pass both flashcard and position
            }
        });
    }



    @Override
    public int getItemCount() {
        return flashcards.size();
    }

    public interface OnRecreateClickListener {
        void onRecreateClick(Flashcard flashcard, int position);
    }

    // Method to retrieve only the selected flashcards
    public List<Flashcard> getSelectedQuestions() {
        List<Flashcard> selectedQuestions = new ArrayList<>();
        for (int i = 0; i < flashcards.size(); i++) {
            if (selectionStates.get(i)) { // Check if the flashcard is selected
                selectedQuestions.add(flashcards.get(i));
            }
        }
        return selectedQuestions;
    }

    // Method to update the adapter's data
    public void updateData(List<Flashcard> newFlashcards) {
        flashcards.clear();
        selectionStates.clear();
        if (newFlashcards != null) {
            flashcards.addAll(newFlashcards);
            for (int i = 0; i < newFlashcards.size(); i++) {
                selectionStates.add(false); // Reset selection states for new data
            }
        }
        notifyDataSetChanged();
    }

    public static class QuestionViewHolder extends RecyclerView.ViewHolder {
        EditText etQuestion, etAnswer;
        CheckBox cbSelect;

        public QuestionViewHolder(@NonNull View itemView) {
            super(itemView);
            etQuestion = itemView.findViewById(R.id.et_generated_question);
            etAnswer = itemView.findViewById(R.id.et_generated_answer);
            cbSelect = itemView.findViewById(R.id.cb_select_question);
        }
    }
}
    ]]>
  </file>
  <file name="EditFlashcardActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\EditFlashcardActivity.java">
    <[CDATA[
package com.example.flashcardapp.main;

import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;
import com.example.flashcardapp.data.Topic;

import androidx.appcompat.app.AppCompatActivity;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EditFlashcardActivity extends AppCompatActivity {

    private EditText etQuestion, etAnswer, etSearchTerm, etUserNote, etTopics;
    private Button btnUpdate, btnContext, btnRelatedQuestion, btnCopy, btnDelete;
    private FlashcardDAO flashcardDAO;
    private Flashcard flashcard;
    private List<Topic> associatedTopics;

    // Cache for topics
    private Map<String, Topic> topicCache = new HashMap<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_edit_flashcard);

        // Initialize views
        etQuestion = findViewById(R.id.et_question);
        etAnswer = findViewById(R.id.et_answer);
        etSearchTerm = findViewById(R.id.et_search_term);
        etUserNote = findViewById(R.id.et_user_note);
        etTopics = findViewById(R.id.et_topics);
        btnUpdate = findViewById(R.id.btn_update);
        btnDelete = findViewById(R.id.btn_delete);
        btnCopy = findViewById(R.id.btn_copy);
        btnContext = findViewById(R.id.btn_context);
        btnRelatedQuestion = findViewById(R.id.btn_generate_related_question);

        // Initialize DAO
        flashcardDAO = new FlashcardDAO(this);
        flashcardDAO.open();

        // Preload the topic cache with all existing topics from the database
        preloadTopicCache();

        // Retrieve flashcard ID from Intent and load flashcard details if ID is valid
        int flashcardId = getIntent().getIntExtra("FLASHCARD_ID", -1);
        if (flashcardId != -1) {
            flashcard = flashcardDAO.getFlashcard(flashcardId);
            if (flashcard != null) {
                populateFields(flashcard);
            }
        }

        // Set up button listeners
        setupButtonListeners();
    }

    private void populateFields(Flashcard flashcard) {
        etQuestion.setText(flashcard.getQuestion());
        etAnswer.setText(flashcard.getAnswer());
        etSearchTerm.setText(flashcard.getSearchTerm());
        etUserNote.setText(flashcard.getUserNote());

        associatedTopics = flashcardDAO.getTopicsForFlashcard(flashcard.getId());
        StringBuilder topicList = new StringBuilder();
        for (Topic topic : associatedTopics) {
            topicList.append(topic.getName()).append(", ");
        }
        if (topicList.length() > 0) {
            topicList.setLength(topicList.length() - 2);
        }
        etTopics.setText(topicList.toString());
    }

    private void setupButtonListeners() {
        btnUpdate.setOnClickListener(v -> updateFlashcard());

        btnCopy.setOnClickListener(v -> copyUserNoteToClipboard());

        btnContext.setOnClickListener(v -> generateContextForQuestion());

        btnRelatedQuestion.setOnClickListener(v -> generateRelatedQuestion());

        btnDelete.setOnClickListener(v -> {
            if (flashcard != null) {
                flashcardDAO.deleteFlashcard(flashcard.getId()); // Call DAO method to delete
                Toast.makeText(this, "Flashcard deleted.", Toast.LENGTH_SHORT).show();
                finish(); // Close the activity and return to the previous screen
            } else {
                Toast.makeText(this, "No flashcard to delete.", Toast.LENGTH_SHORT).show();
            }
        });
    }

    private void updateFlashcard() {
        String question = etQuestion.getText().toString().trim();
        String answer = etAnswer.getText().toString().trim();
        String searchTerm = etSearchTerm.getText().toString().trim();
        String userNote = etUserNote.getText().toString().trim();
        String topics = etTopics.getText().toString().trim();

        if (!question.isEmpty() && !answer.isEmpty()) {
            flashcard.setQuestion(question);
            flashcard.setAnswer(answer);
            flashcard.setSearchTerm(searchTerm);
            flashcard.setUserNote(userNote);
            flashcardDAO.updateFlashcard(flashcard);

            flashcardDAO.clearTopicsForFlashcard(flashcard.getId());
            if (!topics.trim().isEmpty()) {
                String[] topicArray = topics.split(",");
                for (String topicName : topicArray) {
                    topicName = topicName.trim();
                    if (!topicName.isEmpty()) {
                        Topic topic = getOrInsertTopicFromCache(topicName);
                        flashcardDAO.associateFlashcardWithTopic(flashcard.getId(), topic.getId());
                    }
                }
            }

            Toast.makeText(this, "Flashcard updated!", Toast.LENGTH_SHORT).show();
            setResult(RESULT_OK);
            finish();
        } else {
            Toast.makeText(this, "Please enter both question and answer.", Toast.LENGTH_SHORT).show();
        }
    }

    private void copyUserNoteToClipboard() {
        String userNoteContent = etUserNote.getText().toString();
        if (!userNoteContent.isEmpty()) {
            ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
            ClipData clip = ClipData.newPlainText("User Note", userNoteContent);
            clipboard.setPrimaryClip(clip);
            Toast.makeText(this, "User Note copied to clipboard", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(this, "User Note is empty", Toast.LENGTH_SHORT).show();
        }
    }

    private void generateContextForQuestion() {
        String question = " \"" + etQuestion.getText().toString().trim() + "\" with answer: \"" +
                etAnswer.getText().toString().trim() + "\" and additional info: \"" +
                etSearchTerm.getText().toString().trim() + "\".";

        if (!question.isEmpty()) {
            ChatGPTHelper.getContextForQuestion(question, this , new ChatGPTHelper.OnChatGPTResponse() {
                @Override
                public void onSuccess(String response) {
                    runOnUiThread(() -> etUserNote.setText(response));
                }

                @Override
                public void onFailure(String error) {
                    Log.e("EditFlashcardActivity", "Failed to get context: " + error);
                    runOnUiThread(() -> Toast.makeText(EditFlashcardActivity.this, "Failed to get context", Toast.LENGTH_SHORT).show());
                }
            });
        } else {
            Toast.makeText(this, "Please enter a question first", Toast.LENGTH_SHORT).show();
        }
    }

    private void generateRelatedQuestion() {
        String question = etQuestion.getText().toString().trim();
        if (!question.isEmpty()) {
            ChatGPTHelper.generateRelatedQuestion(question, new ChatGPTHelper.OnChatGPTResponse() {
                @Override
                public void onSuccess(String response) {
                    Intent intent = new Intent(EditFlashcardActivity.this, EditFlashcardActivity.class);
                    intent.putExtra("relatedQuestion", response);
                    startActivity(intent);
                }

                @Override
                public void onFailure(String error) {
                    Log.e("EditFlashcardActivity", "Failed to generate related question: " + error);
                    runOnUiThread(() -> Toast.makeText(EditFlashcardActivity.this, "Failed to generate related question", Toast.LENGTH_SHORT).show());
                }
            }, EditFlashcardActivity.this);  // Add the context here
        } else {
            Toast.makeText(this, "Please enter a question first", Toast.LENGTH_SHORT).show();
        }
    }


    private void preloadTopicCache() {
        List<Topic> existingTopics = flashcardDAO.getAllTopics();
        for (Topic topic : existingTopics) {
            topicCache.put(topic.getName(), topic);
        }
    }

    private Topic getOrInsertTopicFromCache(String topicName) {
        if (topicCache.containsKey(topicName)) {
            return topicCache.get(topicName);
        }
        Topic topic = flashcardDAO.getTopicByName(topicName);
        if (topic == null) {
            topic = flashcardDAO.insertTopic(topicName);
        }
        topicCache.put(topicName, topic);
        return topic;
    }

    @Override
    protected void onDestroy() {
        flashcardDAO.close();
        super.onDestroy();
    }
}
    ]]>
  </file>
  <file name="FlashcardAdapter.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\FlashcardAdapter.java">
    <[CDATA[
// File: FlashcardAdapter.java
package com.example.flashcardapp.main;

import android.content.Context;
import android.content.Intent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;

import androidx.recyclerview.widget.RecyclerView;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import static com.example.flashcardapp.main.TimeUtils.formatTimeDifference;

public class FlashcardAdapter extends RecyclerView.Adapter<FlashcardAdapter.ViewHolder> {

    private List<Flashcard> flashcards;
    private Context context;

    public FlashcardAdapter(Context context, List<Flashcard> flashcards) {
        this.context = context;
        // Sort flashcards by nextReview, with overdue ones first
        Collections.sort(flashcards, new Comparator<Flashcard>() {
            @Override
            public int compare(Flashcard f1, Flashcard f2) {
                return Long.compare(f1.getNextReview(), f2.getNextReview());
            }
        });
        this.flashcards = flashcards;
    }

    public class ViewHolder extends RecyclerView.ViewHolder {
        public TextView tvQuestion, tvAnswer, tvTimeDifference, tvInterval;

        public ViewHolder(View itemView) {
            super(itemView);
            tvQuestion = itemView.findViewById(R.id.tv_question);
            tvAnswer = itemView.findViewById(R.id.tv_answer);
            tvTimeDifference = itemView.findViewById(R.id.tv_time_difference);
            tvInterval = itemView.findViewById(R.id.tv_interval);

            // Handle row click to open the edit/delete view
            itemView.setOnClickListener(v -> {
                int position = getAdapterPosition();
                Flashcard flashcard = flashcards.get(position);
                Intent intent = new Intent(context, EditFlashcardActivity.class);
                intent.putExtra("FLASHCARD_ID", flashcard.getId());
                context.startActivity(intent);
            });
        }
    }

    @Override
    public FlashcardAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(context).inflate(R.layout.item_flashcard, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(FlashcardAdapter.ViewHolder holder, int position) {
        Flashcard flashcard = flashcards.get(position);
        holder.tvQuestion.setText(flashcard.getQuestion());
        holder.tvAnswer.setText(flashcard.getAnswer());

        // Calculate time difference in seconds, minutes, and days
        long currentTime = System.currentTimeMillis();
        long nextReviewTime = flashcard.getNextReview();
        long timeDifferenceMillis = nextReviewTime - currentTime;

        long absTimeDifferenceMillis = Math.abs(timeDifferenceMillis);
        String timeDifferenceText = formatTimeDifference(absTimeDifferenceMillis);

        // Add a negative sign if the review is overdue
        if (timeDifferenceMillis < 0) {
            timeDifferenceText = "-" + timeDifferenceText;
        }

        long intervalValue = Math.abs(flashcard.getInterval()) * 1000L;  // Convert seconds to milliseconds

        // Set the time difference and interval values
        holder.tvTimeDifference.setText(timeDifferenceText);
        holder.tvInterval.setText(formatTimeDifference(intervalValue));
    }

    @Override
    public int getItemCount() {
        return flashcards.size();
    }
}
    ]]>
  </file>
  <file name="FlashcardDAO.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\FlashcardDAO.java">
    <[CDATA[
// File: FlashcardDAO.java
package com.example.flashcardapp.main;

import android.annotation.SuppressLint;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.example.flashcardapp.data.Flashcard;
import com.example.flashcardapp.data.Topic;

import java.util.ArrayList;
import java.util.List;

public class FlashcardDAO {
    private SQLiteDatabase database;
    private FlashcardDatabaseHelper dbHelper;

    private String[] flashcardColumns = {
            FlashcardDatabaseHelper.COLUMN_ID,
            FlashcardDatabaseHelper.COLUMN_QUESTION,
            FlashcardDatabaseHelper.COLUMN_ANSWER,
            FlashcardDatabaseHelper.COLUMN_E_FACTOR,
            FlashcardDatabaseHelper.COLUMN_REPETITION,
            FlashcardDatabaseHelper.COLUMN_INTERVAL,
            FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW,
            FlashcardDatabaseHelper.COLUMN_SEARCH_TERM,  // Add search term
            FlashcardDatabaseHelper.COLUMN_USER_NOTE     // Add user note
    };

    private String[] topicColumns = {
            FlashcardDatabaseHelper.COLUMN_TOPIC_ID,
            FlashcardDatabaseHelper.COLUMN_TOPIC_NAME
    };

    public FlashcardDAO(Context context) {
        dbHelper = new FlashcardDatabaseHelper(context);
    }

    public void open() {
        database = dbHelper.getWritableDatabase();
    }

    public void close() {
        dbHelper.close();
    }

    // Method to create a new flashcard
    public Flashcard createFlashcard(Flashcard flashcard) {
        ContentValues values = new ContentValues();
        values.put(FlashcardDatabaseHelper.COLUMN_QUESTION, flashcard.getQuestion());
        values.put(FlashcardDatabaseHelper.COLUMN_ANSWER, flashcard.getAnswer());
        values.put(FlashcardDatabaseHelper.COLUMN_E_FACTOR, flashcard.getEasinessFactor());
        values.put(FlashcardDatabaseHelper.COLUMN_REPETITION, flashcard.getRepetition());
        values.put(FlashcardDatabaseHelper.COLUMN_INTERVAL, flashcard.getInterval());
        values.put(FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW, flashcard.getNextReview());
        values.put(FlashcardDatabaseHelper.COLUMN_SEARCH_TERM, flashcard.getSearchTerm());
        values.put(FlashcardDatabaseHelper.COLUMN_USER_NOTE, flashcard.getUserNote());

        long insertId = database.insert(FlashcardDatabaseHelper.TABLE_FLASHCARDS, null, values);
        flashcard.setId((int) insertId);
        return flashcard;
    }

    // Method to retrieve a flashcard by its ID
    public Flashcard getFlashcard(int id) {
        Cursor cursor = database.query(
                FlashcardDatabaseHelper.TABLE_FLASHCARDS,
                flashcardColumns,
                FlashcardDatabaseHelper.COLUMN_ID + " = ?",
                new String[]{String.valueOf(id)},
                null, null, null
        );

        Flashcard flashcard = null;
        if (cursor != null && cursor.moveToFirst()) {
            flashcard = cursorToFlashcard(cursor);
            cursor.close();
        }

        return flashcard;
    }


    public Flashcard getNextDueFlashcard(long currentTime) {
        Flashcard flashcard = null;

        // Query to get the flashcard with the closest next_review time that is due
        String query = "SELECT * FROM view_filtered_flashcards " +
                " WHERE " + FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW + " <= ?" +
                " ORDER BY " + FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW + " DESC " +
                " LIMIT 1"; // Limit to the first result

        Cursor cursor = database.rawQuery(query, new String[]{String.valueOf(currentTime)});

        if (cursor.moveToFirst()) {
            flashcard = cursorToFlashcard(cursor); // Convert the cursor to a flashcard object
        }
        cursor.close();

        return flashcard;
    }


    // Method to update an existing flashcard
    public void updateFlashcard(Flashcard flashcard) {
        ContentValues values = new ContentValues();
        values.put(FlashcardDatabaseHelper.COLUMN_QUESTION, flashcard.getQuestion());
        values.put(FlashcardDatabaseHelper.COLUMN_ANSWER, flashcard.getAnswer());
        values.put(FlashcardDatabaseHelper.COLUMN_E_FACTOR, flashcard.getEasinessFactor());
        values.put(FlashcardDatabaseHelper.COLUMN_REPETITION, flashcard.getRepetition());
        values.put(FlashcardDatabaseHelper.COLUMN_INTERVAL, flashcard.getInterval());
        values.put(FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW, flashcard.getNextReview());
        values.put(FlashcardDatabaseHelper.COLUMN_SEARCH_TERM, flashcard.getSearchTerm());
        values.put(FlashcardDatabaseHelper.COLUMN_USER_NOTE, flashcard.getUserNote());

        database.update(
                FlashcardDatabaseHelper.TABLE_FLASHCARDS,
                values,
                FlashcardDatabaseHelper.COLUMN_ID + " = ?",
                new String[]{String.valueOf(flashcard.getId())}
        );
    }

    // Method to clear all topic associations for a flashcard
    public void clearTopicsForFlashcard(int flashcardId) {
        int rowsDeleted = database.delete(
                FlashcardDatabaseHelper.TABLE_FLASHCARD_TOPIC_CROSS_REF,
                FlashcardDatabaseHelper.COLUMN_FLASHCARD_ID + " = ?",
                new String[]{String.valueOf(flashcardId)}
        );
        Log.d("Database", "Rows deleted: " + rowsDeleted);
    }

    // Method to insert a topic
    public Topic insertTopic(String topicName) {
        ContentValues values = new ContentValues();
        values.put(FlashcardDatabaseHelper.COLUMN_TOPIC_NAME, topicName);

        long topicId = database.insertWithOnConflict(
                FlashcardDatabaseHelper.TABLE_TOPICS, null, values, SQLiteDatabase.CONFLICT_IGNORE);

        Topic topic = new Topic(topicName);
        topic.setId((int) topicId);
        return topic;
    }

    public void updateTopicSelection(int topicId, boolean isSelected) {
        ContentValues values = new ContentValues();
        values.put(FlashcardDatabaseHelper.COLUMN_TOPIC_SELECTED, isSelected ? 1 : 0);
        database.update(
                FlashcardDatabaseHelper.TABLE_TOPICS,
                values,
                FlashcardDatabaseHelper.COLUMN_TOPIC_ID + " = ?",
                new String[]{String.valueOf(topicId)}
        );
    }

    // Method to associate a flashcard with a topic
    public void associateFlashcardWithTopic(int flashcardId, int topicId) {
        ContentValues values = new ContentValues();
        values.put(FlashcardDatabaseHelper.COLUMN_FLASHCARD_ID, flashcardId);
        values.put(FlashcardDatabaseHelper.COLUMN_TOPIC_ID_REF, topicId);

        database.insert(FlashcardDatabaseHelper.TABLE_FLASHCARD_TOPIC_CROSS_REF, null, values);
    }

    // Get all topics for a flashcard
    public List<Topic> getTopicsForFlashcard(int flashcardId) {
        List<Topic> topics = new ArrayList<>();
        Cursor cursor = database.rawQuery("SELECT * FROM " + FlashcardDatabaseHelper.TABLE_TOPICS + " t" +
                " INNER JOIN " + FlashcardDatabaseHelper.TABLE_FLASHCARD_TOPIC_CROSS_REF + " c" +
                " ON t." + FlashcardDatabaseHelper.COLUMN_TOPIC_ID + " = c." + FlashcardDatabaseHelper.COLUMN_TOPIC_ID_REF +
                " WHERE c." + FlashcardDatabaseHelper.COLUMN_FLASHCARD_ID + " = ?", new String[]{String.valueOf(flashcardId)});

        if (cursor.moveToFirst()) {
            do {
                Topic topic = new Topic();
                topic.setId(cursor.getInt(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_TOPIC_ID)));
                topic.setName(cursor.getString(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_TOPIC_NAME)));
                topics.add(topic);
            } while (cursor.moveToNext());
        }
        cursor.close();
        return topics;
    }

    // Method to retrieve all topics
    public List<Topic> getAllTopics() {
        List<Topic> topics = new ArrayList<>();
        Cursor cursor = database.query(
                FlashcardDatabaseHelper.TABLE_TOPICS,
                new String[]{FlashcardDatabaseHelper.COLUMN_TOPIC_ID, FlashcardDatabaseHelper.COLUMN_TOPIC_NAME,FlashcardDatabaseHelper.COLUMN_TOPIC_SELECTED},
                null, null, null, null, null
        );

        if (cursor != null && cursor.moveToFirst()) {
            do {
                @SuppressLint("Range") int topicId = cursor.getInt(cursor.getColumnIndex(FlashcardDatabaseHelper.COLUMN_TOPIC_ID));
                @SuppressLint("Range") String topicName = cursor.getString(cursor.getColumnIndex(FlashcardDatabaseHelper.COLUMN_TOPIC_NAME));
                @SuppressLint("Range") Boolean topicSelected = cursor.getInt(cursor.getColumnIndex(FlashcardDatabaseHelper.COLUMN_TOPIC_SELECTED)) ==1;
                topics.add(new Topic(topicId, topicName, topicSelected));
            } while (cursor.moveToNext());

            cursor.close();
        }

        return topics;
    }

    // Method to retrieve a topic by name
    public Topic getTopicByName(String topicName) {
        Topic topic = null;
        Cursor cursor = database.query(
                FlashcardDatabaseHelper.TABLE_TOPICS,
                new String[]{FlashcardDatabaseHelper.COLUMN_TOPIC_ID, FlashcardDatabaseHelper.COLUMN_TOPIC_NAME},
                FlashcardDatabaseHelper.COLUMN_TOPIC_NAME + " = ?",
                new String[]{topicName},
                null, null, null
        );

        if (cursor != null && cursor.moveToFirst()) {
            @SuppressLint("Range") int topicId = cursor.getInt(cursor.getColumnIndex(FlashcardDatabaseHelper.COLUMN_TOPIC_ID));
            @SuppressLint("Range") String retrievedTopicName = cursor.getString(cursor.getColumnIndex(FlashcardDatabaseHelper.COLUMN_TOPIC_NAME));
            @SuppressLint("Range") Boolean topicSelected = cursor.getInt(cursor.getColumnIndex(FlashcardDatabaseHelper.COLUMN_TOPIC_SELECTED)) == 1;
            topic = new Topic(topicId, retrievedTopicName, topicSelected);
            cursor.close();
        }

        return topic;
    }


    // Helper method to convert a cursor to a Flashcard object
    private Flashcard cursorToFlashcard(Cursor cursor) {
        Flashcard flashcard = new Flashcard();
        flashcard.setId(cursor.getInt(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_ID)));
        flashcard.setQuestion(cursor.getString(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_QUESTION)));
        flashcard.setAnswer(cursor.getString(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_ANSWER)));
        flashcard.setEasinessFactor(cursor.getDouble(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_E_FACTOR)));
        flashcard.setRepetition(cursor.getInt(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_REPETITION)));
        flashcard.setInterval(cursor.getInt(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_INTERVAL)));
        flashcard.setNextReview(cursor.getLong(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW)));
        flashcard.setSearchTerm(cursor.getString(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_SEARCH_TERM)));  // Get search term
        flashcard.setUserNote(cursor.getString(cursor.getColumnIndexOrThrow(FlashcardDatabaseHelper.COLUMN_USER_NOTE)));      // Get user note

        List<Topic> topics = getTopicsForFlashcard(flashcard.getId());
        flashcard.setTopics(topics);

        return flashcard;
    }

    public void deleteFlashcard(int flashcardId) {
        // Delete the flashcard from the flashcards table
        database.delete(
                FlashcardDatabaseHelper.TABLE_FLASHCARDS,
                FlashcardDatabaseHelper.COLUMN_ID + " = ?",
                new String[]{String.valueOf(flashcardId)}
        );

        // Optionally, clear the associated topics if any
        database.delete(
                FlashcardDatabaseHelper.TABLE_FLASHCARD_TOPIC_CROSS_REF,
                FlashcardDatabaseHelper.COLUMN_FLASHCARD_ID + " = ?",
                new String[]{String.valueOf(flashcardId)}
        );
    }

    // Get flashcards with next_review in the future (ascending)
    public List<Flashcard> getFutureFlashcards() {
        List<Flashcard> flashcards = new ArrayList<>();

        String query = "SELECT * FROM view_filtered_flashcards WHERE " + FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW + " > ?" +
                " ORDER BY " + FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW + " ASC";

        Cursor cursor = database.rawQuery(query, new String[]{String.valueOf(System.currentTimeMillis())});

        if (cursor.moveToFirst()) {
            do {
                flashcards.add(cursorToFlashcard(cursor));
            } while (cursor.moveToNext());
        }
        cursor.close();

        return flashcards;
    }

    public List<Flashcard> getPastFlashcards() {
        List<Flashcard> flashcards = new ArrayList<>();

        String query = "SELECT * FROM view_filtered_flashcards WHERE " + FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW + " <= ?" +
                " ORDER BY " + FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW + " DESC";

        Cursor cursor = database.rawQuery(query, new String[]{String.valueOf(System.currentTimeMillis())});

        if (cursor.moveToFirst()) {
            do {
                flashcards.add(cursorToFlashcard(cursor));
            } while (cursor.moveToNext());
        }
        cursor.close();

        return flashcards;
    }


    public List<Flashcard> getAllFlashcards() {
        List<Flashcard> flashcards = new ArrayList<>();

        Cursor cursor = database.query(
                FlashcardDatabaseHelper.TABLE_FLASHCARDS,
                flashcardColumns, // The array of column names defined in the DAO
                null, // No selection criteria
                null, // No selection arguments
                null, // No group by
                null, // No having
                FlashcardDatabaseHelper.COLUMN_NEXT_REVIEW + " ASC" // Order by next review
        );

        if (cursor != null && cursor.moveToFirst()) {
            do {
                Flashcard flashcard = cursorToFlashcard(cursor); // Convert the cursor to a Flashcard object
                flashcards.add(flashcard);
            } while (cursor.moveToNext());
            cursor.close();
        }

        return flashcards;
    }


    public int[] getPastAndFutureQuestionsCount() {

        long currentTime = System.currentTimeMillis();


        String query = "SELECT " +
                "SUM(CASE WHEN nextReview <= ? THEN 1 ELSE 0 END) AS pastCount, " +
                "SUM(CASE WHEN nextReview > ? THEN 1 ELSE 0 END) AS futureCount " +
                "FROM view_filtered_flashcards";

        Cursor cursor = database.rawQuery(query, new String[]{String.valueOf(currentTime), String.valueOf(currentTime)});
        cursor.moveToFirst();
        @SuppressLint("Range") int pastCount = cursor.getInt(cursor.getColumnIndex("pastCount"));
        @SuppressLint("Range") int futureCount = cursor.getInt(cursor.getColumnIndex("futureCount"));
        cursor.close();

        return new int[]{pastCount, futureCount}; // Return both counts as an array
    }


    public void insertReviewHistory(
            int questionId,
            int confidenceLevel,
            long timestamp,
            long timeSinceLastSeen,
            int interval,
            String reviewType,
            long answerDuration
    ) {
        ContentValues values = new ContentValues();
        values.put(FlashcardDatabaseHelper.COLUMN_HISTORY_QUESTION_ID, questionId);
        values.put(FlashcardDatabaseHelper.COLUMN_HISTORY_CONFIDENCE_LEVEL, confidenceLevel);
        values.put(FlashcardDatabaseHelper.COLUMN_HISTORY_TIMESTAMP, timestamp);
        values.put(FlashcardDatabaseHelper.COLUMN_HISTORY_TIME_SINCE_LAST_SEEN, timeSinceLastSeen);
        values.put(FlashcardDatabaseHelper.COLUMN_HISTORY_INTERVAL, interval);
        values.put(FlashcardDatabaseHelper.COLUMN_HISTORY_REVIEW_TYPE, reviewType);
        values.put(FlashcardDatabaseHelper.COLUMN_HISTORY_ANSWER_DURATION, answerDuration);

        database.insert(FlashcardDatabaseHelper.TABLE_REVIEW_HISTORY, null, values);
    }


    // Get flashcards with next_review in the past (descending)

}
    ]]>
  </file>
  <file name="FlashcardDatabaseHelper.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\FlashcardDatabaseHelper.java">
    <[CDATA[
// File: FlashcardDatabaseHelper.java
package com.example.flashcardapp.main;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class FlashcardDatabaseHelper extends SQLiteOpenHelper {
    private static final String DATABASE_NAME = "flashcards.db";
    private static final int DATABASE_VERSION = 12;  // Incremented for new tables


    // Table and column names
    public static final String TABLE_FLASHCARDS = "flashcards";
    public static final String TABLE_TOPICS = "topics";
    public static final String TABLE_FLASHCARD_TOPIC_CROSS_REF = "flashcard_topic_cross_ref";

    // Flashcard columns
    public static final String COLUMN_ID = "id";
    public static final String COLUMN_QUESTION = "question";
    public static final String COLUMN_ANSWER = "answer";
    public static final String COLUMN_E_FACTOR = "easinessFactor";
    public static final String COLUMN_REPETITION = "repetition";
    public static final String COLUMN_INTERVAL = "interval";
    public static final String COLUMN_NEXT_REVIEW = "nextReview";
    public static final String COLUMN_SEARCH_TERM = "searchTerm";
    public static final String COLUMN_USER_NOTE = "userNote";

    // Topic columns
    public static final String COLUMN_TOPIC_ID = "id";
    public static final String COLUMN_TOPIC_NAME = "name";
    public static final String COLUMN_TOPIC_SELECTED = "selected";

    // CrossRef columns
    public static final String COLUMN_FLASHCARD_ID = "flashcard_id";
    public static final String COLUMN_TOPIC_ID_REF = "topic_id";

    // SQL statement to create the flashcards table
    private static final String TABLE_CREATE_FLASHCARDS =
            "CREATE TABLE " + TABLE_FLASHCARDS + " (" +
                    COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
                    COLUMN_QUESTION + " TEXT, " +
                    COLUMN_ANSWER + " TEXT, " +
                    COLUMN_E_FACTOR + " REAL, " +
                    COLUMN_REPETITION + " INTEGER, " +
                    COLUMN_INTERVAL + " INTEGER, " +
                    COLUMN_NEXT_REVIEW + " INTEGER, " +
                    COLUMN_SEARCH_TERM + " TEXT, " +    // Add searchTerm column
                    COLUMN_USER_NOTE + " TEXT" +        // Add userNote column
                    ");";

    // SQL statement to create the topics table
    private static final String TABLE_CREATE_TOPICS =
            "CREATE TABLE " + TABLE_TOPICS + " (" +
                    COLUMN_TOPIC_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
                    COLUMN_TOPIC_NAME + " TEXT, " +
                    COLUMN_TOPIC_SELECTED + " INTEGER DEFAULT 0" + // Added the selected column
                    ");";


    // SQL statement to create the flashcard_topic_cross_ref table
    private static final String TABLE_CREATE_FLASHCARD_TOPIC_CROSS_REF =
            "CREATE TABLE " + TABLE_FLASHCARD_TOPIC_CROSS_REF + " (" +
                    COLUMN_FLASHCARD_ID + " INTEGER, " +
                    COLUMN_TOPIC_ID_REF + " INTEGER, " +
                    "PRIMARY KEY(" + COLUMN_FLASHCARD_ID + ", " + COLUMN_TOPIC_ID_REF + "), " +
                    "FOREIGN KEY(" + COLUMN_FLASHCARD_ID + ") REFERENCES " + TABLE_FLASHCARDS + "(" + COLUMN_ID + "), " +
                    "FOREIGN KEY(" + COLUMN_TOPIC_ID_REF + ") REFERENCES " + TABLE_TOPICS + "(" + COLUMN_TOPIC_ID + ")" +
                    ");";

    private static final String CREATE_VIEW_FILTERED_FLASHCARDS =
            "CREATE VIEW IF NOT EXISTS view_filtered_flashcards AS " +
                    "SELECT DISTINCT flashcards.* " +
                    "FROM flashcards " +
                    "JOIN flashcard_topic_cross_ref ON flashcards.id = flashcard_topic_cross_ref.flashcard_id " +
                    "JOIN topics ON flashcard_topic_cross_ref.topic_Id = topics.id " +
                    "WHERE topics.selected = 1;";


    // Review History Table Constants
    public static final String TABLE_REVIEW_HISTORY = "review_history";
    public static final String COLUMN_HISTORY_ID = "id";
    public static final String COLUMN_HISTORY_QUESTION_ID = "question_id";
    public static final String COLUMN_HISTORY_CONFIDENCE_LEVEL = "confidence_level";
    public static final String COLUMN_HISTORY_TIMESTAMP = "timestamp";
    public static final String COLUMN_HISTORY_TIME_SINCE_LAST_SEEN = "time_since_last_seen";
    public static final String COLUMN_HISTORY_INTERVAL = "interval";
    public static final String COLUMN_HISTORY_REVIEW_TYPE = "review_type";
    public static final String COLUMN_HISTORY_ANSWER_DURATION = "answer_duration";


    private static final String TABLE_CREATE_REVIEW_HISTORY = "CREATE TABLE " + TABLE_REVIEW_HISTORY + " (" +
            COLUMN_HISTORY_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
            COLUMN_HISTORY_QUESTION_ID + " INTEGER, " +
            COLUMN_HISTORY_CONFIDENCE_LEVEL + " INTEGER, " +
            COLUMN_HISTORY_TIMESTAMP + " INTEGER, " +
            COLUMN_HISTORY_TIME_SINCE_LAST_SEEN + " INTEGER, " +
            COLUMN_HISTORY_INTERVAL + " INTEGER, " +
            COLUMN_HISTORY_REVIEW_TYPE + " TEXT, " + // Review type (e.g., "normal", "quiz")
            COLUMN_HISTORY_ANSWER_DURATION + " INTEGER, " + // Answer duration in milliseconds
            "FOREIGN KEY(" + COLUMN_HISTORY_QUESTION_ID + ") REFERENCES " + TABLE_FLASHCARDS + "(" + COLUMN_ID + ") " +
            "ON DELETE CASCADE);";

    public FlashcardDatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(TABLE_CREATE_FLASHCARDS);
        db.execSQL(TABLE_CREATE_TOPICS);
        db.execSQL(TABLE_CREATE_FLASHCARD_TOPIC_CROSS_REF);
        db.execSQL(CREATE_VIEW_FILTERED_FLASHCARDS);
        db.execSQL(TABLE_CREATE_REVIEW_HISTORY);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // Handle database upgrade
        if (oldVersion < 2) {
            db.execSQL("ALTER TABLE " + TABLE_FLASHCARDS + " ADD COLUMN " + COLUMN_SEARCH_TERM + " TEXT;");
            db.execSQL("ALTER TABLE " + TABLE_FLASHCARDS + " ADD COLUMN " + COLUMN_USER_NOTE + " TEXT;");
            db.execSQL(TABLE_CREATE_TOPICS);
            db.execSQL(TABLE_CREATE_FLASHCARD_TOPIC_CROSS_REF);
        }
        if (oldVersion < 3){
            db.execSQL("ALTER TABLE topics ADD COLUMN selected INTEGER DEFAULT 0");
        }

        if (oldVersion < 11){
            db.execSQL(TABLE_CREATE_REVIEW_HISTORY);
        }

        db.execSQL("DROP VIEW IF EXISTS view_filtered_flashcards;");
        db.execSQL(CREATE_VIEW_FILTERED_FLASHCARDS);


    }





}
    ]]>
  </file>
  <file name="GeneratedQuestionAdapter.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\GeneratedQuestionAdapter.java">
    <[CDATA[
package com.example.flashcardapp.main;

import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.EditText;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import java.util.ArrayList;
import java.util.List;

public class GeneratedQuestionAdapter extends RecyclerView.Adapter<GeneratedQuestionAdapter.QuestionViewHolder> {

    private final List<Flashcard> questions;
    private final List<Boolean> selected;

    public GeneratedQuestionAdapter(List<Flashcard> questions) {
        this.questions = questions;
        this.selected = new ArrayList<>();
        for (int i = 0; i < questions.size(); i++) {
            selected.add(false); // Initially, no questions are selected
        }
    }

    @NonNull
    @Override
    public QuestionViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_generated_question, parent, false);
        return new QuestionViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull QuestionViewHolder holder, int position) {
        Flashcard question = questions.get(position);

        holder.etQuestion.setText(question.getQuestion());
        holder.etAnswer.setText(question.getAnswer());
        holder.cbSelect.setChecked(selected.get(position));

        // Handle question text change
        holder.etQuestion.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                question.setQuestion(s.toString());
            }

            @Override
            public void afterTextChanged(Editable s) {}
        });

        // Handle answer text change
        holder.etAnswer.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                question.setAnswer(s.toString());
            }

            @Override
            public void afterTextChanged(Editable s) {}
        });

        // Handle selection state
        holder.cbSelect.setOnCheckedChangeListener((buttonView, isChecked) -> selected.set(position, isChecked));
    }

    @Override
    public int getItemCount() {
        return questions.size();
    }

    public List<Flashcard> getSelectedQuestions() {
        List<Flashcard> selectedQuestions = new ArrayList<>();
        for (int i = 0; i < questions.size(); i++) {
            if (selected.get(i)) {
                selectedQuestions.add(questions.get(i));
            }
        }
        return selectedQuestions;
    }

    static class QuestionViewHolder extends RecyclerView.ViewHolder {
        EditText etQuestion, etAnswer;
        CheckBox cbSelect;

        public QuestionViewHolder(@NonNull View itemView) {
            super(itemView);
            etQuestion = itemView.findViewById(R.id.et_generated_question);
            etAnswer = itemView.findViewById(R.id.et_generated_answer);
            cbSelect = itemView.findViewById(R.id.cb_select_question);
        }
    }
}
    ]]>
  </file>
  <file name="GenerateQuestionsActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\GenerateQuestionsActivity.java">
    <[CDATA[
package com.example.flashcardapp.main;

import android.os.Bundle;
import android.widget.Button;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;
import androidx.lifecycle.ViewModelProvider;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;
import com.example.flashcardapp.viewmodel.ImportFlashcardsViewModel;

import java.util.ArrayList;
import java.util.List;

public class GenerateQuestionsActivity extends AppCompatActivity {

    private Button btnGenerate, btnSave;
    private RecyclerView rvGeneratedQuestions;
    private ChatGPTQuestionAdapter adapter;
    private ImportFlashcardsViewModel viewModel;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_generate_questions);

        // Initialize UI components
        btnGenerate = findViewById(R.id.btn_generate);
        btnSave = findViewById(R.id.btn_save);
        rvGeneratedQuestions = findViewById(R.id.rv_generated_questions);

        // Initialize ViewModel
        viewModel = new ViewModelProvider(this).get(ImportFlashcardsViewModel.class);

        // Initialize DAO and pass it to ViewModel
        FlashcardDAO flashcardDAO = new FlashcardDAO(this); // Use Activity context
        flashcardDAO.open(); // Ensure the DAO is initialized
        viewModel.initialize(flashcardDAO); // Pass the DAO to the ViewModel

        // Setup RecyclerView
        adapter = new ChatGPTQuestionAdapter(new ArrayList<>(), null); // Corrected line
        rvGeneratedQuestions.setLayoutManager(new LinearLayoutManager(this));
        rvGeneratedQuestions.setAdapter(adapter);

        // Observe LiveData for changes
        viewModel.getGeneratedQuestions().observe(this, generatedQuestions -> {
            adapter.updateData(generatedQuestions); // Update adapter data
        });

        // Button listeners
        btnGenerate.setOnClickListener(v -> generateQuestions());
        btnSave.setOnClickListener(v -> saveQuestions());
    }


    private void generateQuestions() {
        List<Flashcard> existingQuestions = viewModel.fetchExistingQuestions();
        String promptGenerateQuestions = getString(R.string.prompt_generate_questions_activity); // Retrieve prompt from strings.xml

        viewModel.generateQuestions(existingQuestions, promptGenerateQuestions, this,  new ImportFlashcardsViewModel.OnGenerateCallback() {
            @Override
            public void onSuccess() {
                runOnUiThread(() -> {
                    adapter.notifyDataSetChanged();
                    Toast.makeText(GenerateQuestionsActivity.this, "Questions generated successfully!", Toast.LENGTH_SHORT).show();
                });
            }

            @Override
            public void onFailure(String error) {
                runOnUiThread(() -> Toast.makeText(GenerateQuestionsActivity.this, "Error: " + error, Toast.LENGTH_SHORT).show());
            }
        });
    }


    private void saveQuestions() {
        List<Flashcard> selectedQuestions = adapter.getSelectedQuestions();
        viewModel.saveFlashcards(selectedQuestions);
        Toast.makeText(this, "Selected questions saved!", Toast.LENGTH_SHORT).show();
    }
}
    ]]>
  </file>
  <file name="ImportFlashcardsActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\ImportFlashcardsActivity.java">
    <[CDATA[
package com.example.flashcardapp.main;

import android.content.ClipData;
import android.content.ClipboardManager;
import android.os.Bundle;
import android.util.Log;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;
import androidx.lifecycle.ViewModelProvider;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;
import com.example.flashcardapp.util.FlashcardUtils;
import com.example.flashcardapp.viewmodel.ImportFlashcardsViewModel;

import java.util.List;

public class ImportFlashcardsActivity extends AppCompatActivity {

    private EditText etJsonInput;
    private Button btnImport, btnCopyText, btnClearText;
    private ImportFlashcardsViewModel viewModel; // ViewModel reference

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_import_flashcards);

        // Initialize views
        etJsonInput = findViewById(R.id.et_xml_input);
        btnImport = findViewById(R.id.btn_import);
        btnCopyText = findViewById(R.id.btn_copy_text);
        btnClearText = findViewById(R.id.btn_clear_text);

        // Initialize ViewModel
        viewModel = new ViewModelProvider(this).get(ImportFlashcardsViewModel.class);

        // Retrieve prompts from XML resources
        String promptGenerateQuestions = getString(R.string.prompt_generate_questions);
        String promptExampleExistingQuestions = getString(R.string.prompt_example_existing_questions);

        Log.d("Debug", "Prompt String: " + promptExampleExistingQuestions);
        // Replace &quot; with actual quotation marks
        promptExampleExistingQuestions = promptExampleExistingQuestions.replace("&quot;", "\"");

        // Concatenate and set text to EditText
        String prefilledText = promptGenerateQuestions + "\n\n" + promptExampleExistingQuestions;
        etJsonInput.setText(prefilledText);

        // Import button listener
        btnImport.setOnClickListener(v -> {
            String jsonInput = etJsonInput.getText().toString().trim();
            if (!jsonInput.isEmpty()) {
                try {
                    // Parse flashcards using the utility method
                    List<Flashcard> flashcards = FlashcardUtils.parseFlashcardsFromJson(jsonInput);

                    // Save flashcards using ViewModel
                    viewModel.saveFlashcards(flashcards);

                    // Show success message
                    String message = "Imported " + flashcards.size() + " flashcards!";
                    Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
                } catch (Exception e) {
                    // Handle JSON parsing errors
                    Toast.makeText(this, "Invalid JSON input. Please check the format.", Toast.LENGTH_SHORT).show();
                    Log.e("FlashcardImport", "Error parsing JSON input", e);
                }
            } else {
                // Handle empty input
                Toast.makeText(this, "Please enter JSON input.", Toast.LENGTH_SHORT).show();
            }
        });

        // Copy text button listener
        btnCopyText.setOnClickListener(v -> {
            String textToCopy = etJsonInput.getText().toString().trim();
            if (!textToCopy.isEmpty()) {
                ClipboardManager clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
                ClipData clip = ClipData.newPlainText("Flashcard JSON", textToCopy);
                clipboard.setPrimaryClip(clip);
                Toast.makeText(this, "Text copied to clipboard!", Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(this, "Nothing to copy!", Toast.LENGTH_SHORT).show();
            }
        });

        // Clear text button listener
        btnClearText.setOnClickListener(v -> etJsonInput.setText(""));
    }


}
    ]]>
  </file>
  <file name="ListFlashcardsActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\ListFlashcardsActivity.java">
    <[CDATA[
// File: ListFlashcardsActivity.java
package com.example.flashcardapp.main;

import android.os.Bundle;
import android.widget.ToggleButton;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;

import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.util.ArrayList;
import java.util.List;

public class ListFlashcardsActivity extends AppCompatActivity {

    private ToggleButton toggleReviewTime;
    private FlashcardDAO flashcardDAO;
    private List<Flashcard> flashcards;
    private FlashcardAdapter flashcardAdapter; // Assuming you're using a RecyclerView adapter

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_list_flashcards);

        // Initialize views
        toggleReviewTime = findViewById(R.id.toggle_review_time);
        flashcardDAO = new FlashcardDAO(this);
        flashcardDAO.open();

        // Set up the adapter and the RecyclerView
        flashcards = new ArrayList<>();
        flashcardAdapter = new FlashcardAdapter(this, flashcards); // Adjust the constructor as per your adapter
        RecyclerView recyclerView = findViewById(R.id.recycler_view_flashcards);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        recyclerView.setAdapter(flashcardAdapter);

        // Load initial data (future questions ascending)
        loadFlashcards(true);

        // Set toggle button listener to switch between past and future
        toggleReviewTime.setOnCheckedChangeListener((buttonView, isChecked) -> {
            if (isChecked) {
                // Show past questions, descending order
                loadFlashcards(false);
            } else {
                // Show future questions, ascending order
                loadFlashcards(true);
            }
        });
    }

    private void loadFlashcards(boolean showFuture) {
        // Clear the current list
        flashcards.clear();

        if (showFuture) {
            // Load questions in the future, ordered ascending
            flashcards.addAll(flashcardDAO.getFutureFlashcards());
        } else {
            // Load questions in the past, ordered descending
            flashcards.addAll(flashcardDAO.getPastFlashcards());
        }

        // Notify the adapter that the data has changed
        flashcardAdapter.notifyDataSetChanged();
    }

    @Override
    protected void onDestroy() {
        flashcardDAO.close();
        super.onDestroy();
    }
}    ]]>
  </file>
  <file name="MainActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\MainActivity.java">
    <[CDATA[
// File: MainActivity.java
package com.example.flashcardapp.main;

import android.content.Intent;
import android.os.Bundle;
import android.widget.Button;

import com.example.flashcardapp.R;

import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {

    private Button btnAddFlashcard, btnReviewFlashcards, btnListFlashcards, btnImportExport, btnCreate;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

         btnAddFlashcard = findViewById(R.id.btn_action);
         btnReviewFlashcards = findViewById(R.id.btn_review_flashcards);
         btnListFlashcards = findViewById(R.id.btn_list_flashcards);
         btnImportExport = findViewById(R.id.btn_import_export);
         btnCreate = findViewById(R.id.btn_create);

         btnAddFlashcard.setOnClickListener(v -> {
            // FlashcardDAO flashcardDAO = new FlashcardDAO(this);
            // flashcardDAO.open();
            // flashcardDAO.deleteAllData();

           //  Intent intent = new Intent(MainActivity.this, AddFlashcardActivity.class);
             Intent intent = new Intent(MainActivity.this, TopicSelectionActivity.class);
              startActivity(intent);
         });




         btnReviewFlashcards.setOnClickListener(v -> {
             Intent intent = new Intent(MainActivity.this, ReviewFlashcardsActivity.class);
             startActivity(intent);
         });

         btnListFlashcards.setOnClickListener(v -> {
             Intent intent = new Intent(MainActivity.this, ListFlashcardsActivity.class);
             startActivity(intent);
         });

         btnImportExport.setOnClickListener(v -> {
             Intent intent = new Intent(MainActivity.this, ImportFlashcardsActivity.class);
             startActivity(intent);
         });

        btnCreate.setOnClickListener(v -> {
            Intent intent = new Intent(MainActivity.this, GenerateQuestionsActivity.class);
            startActivity(intent);
        });
    }
}
    ]]>
  </file>
  <file name="ReviewFlashcardsActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\ReviewFlashcardsActivity.java">
    <[CDATA[
// File: ReviewFlashcardsActivity.java
package com.example.flashcardapp.main;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Flashcard;

import java.util.HashSet;
import java.util.Set;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;

public class ReviewFlashcardsActivity extends AppCompatActivity {


    private int totalQuestionsCount = 0; // Counter for total questions
    private int questionsMovedCount = 0; // Counter for questions moved by >1 day
    private int score = 0; // Score for session
    private TextView tvTotalQuestions, tvQuestionsMoved, tvPast, tvFuture;
    private TextView tvQuestion, tvAnswer;
    private Button btnShowAnswer;
    private Button btnForgot, btnStruggling, btnUnsure, btnOkay, btnGood, btnPerfect;
    private FlashcardDAO flashcardDAO;
    private Flashcard currentFlashcard;

    private long answerStartTime;


    private Set<Integer> seenFlashcards = new HashSet<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_review_flashcards);

        // Initialize views
        tvTotalQuestions = findViewById(R.id.tv_total_questions);
        tvQuestionsMoved = findViewById(R.id.tv_questions_moved);
        tvPast = findViewById(R.id.tv_past_questions);
        tvFuture = findViewById(R.id.tv_future_questions);
        tvQuestion = findViewById(R.id.tv_question);
        tvAnswer = findViewById(R.id.tv_answer);
        btnShowAnswer = findViewById(R.id.btn_show_answer);
        btnForgot = findViewById(R.id.btn_forgot);
        btnStruggling = findViewById(R.id.btn_struggling);
        btnUnsure = findViewById(R.id.btn_unsure);
        btnOkay = findViewById(R.id.btn_okay);
        btnGood = findViewById(R.id.btn_good);
        btnPerfect = findViewById(R.id.btn_perfect);

        // Hide buttons by default
        findViewById(R.id.low_confidence_buttons).setVisibility(View.GONE);
        findViewById(R.id.high_confidence_buttons).setVisibility(View.GONE);

        flashcardDAO = new FlashcardDAO(this);
        flashcardDAO.open();

        // Start the review process
        showNextFlashcard();

        tvQuestion.setOnClickListener(v -> openEditQuestion());

        btnShowAnswer.setOnClickListener(v -> {
            if (currentFlashcard != null) {
                tvAnswer.setText(currentFlashcard.getAnswer());
                tvAnswer.setVisibility(View.VISIBLE);
                btnShowAnswer.setVisibility(View.GONE);

                // Start the timer for tracking answer duration
                answerStartTime = System.nanoTime();

                // Show confidence buttons
                findViewById(R.id.low_confidence_buttons).setVisibility(View.VISIBLE);
                findViewById(R.id.high_confidence_buttons).setVisibility(View.VISIBLE);
            }
        });

        // Confidence button listeners
        btnForgot.setOnClickListener(v -> handleConfidence(0));
        btnStruggling.setOnClickListener(v -> handleConfidence(1));
        btnUnsure.setOnClickListener(v -> handleConfidence(2));
        btnOkay.setOnClickListener(v -> handleConfidence(3));
        btnGood.setOnClickListener(v -> handleConfidence(4));
        btnPerfect.setOnClickListener(v -> handleConfidence(5));
    }

    private void showNextFlashcard() {
        // Fetch the next due flashcard from the database
        currentFlashcard = flashcardDAO.getNextDueFlashcard(System.currentTimeMillis());

        if (currentFlashcard != null) {
            // Display the flashcard
            tvQuestion.setText(currentFlashcard.getQuestion());
            tvAnswer.setVisibility(View.GONE);
            findViewById(R.id.low_confidence_buttons).setVisibility(View.GONE);
            findViewById(R.id.high_confidence_buttons).setVisibility(View.GONE);
            btnShowAnswer.setVisibility(View.VISIBLE);


            // Increment and update total question count

            // Track the flashcard as seen
            seenFlashcards.add(currentFlashcard.getId());
            totalQuestionsCount++;
            updateCounters();

        } else {
            // Show a Toast message if no flashcards are due
            Toast.makeText(this, "No flashcards due for review!", Toast.LENGTH_SHORT).show();
            finish(); // End the activity if there are no flashcards left
        }
    }

    private void handleConfidence(int quality) {
        long currentTime = System.currentTimeMillis();
        long answerDuration = (System.nanoTime() - answerStartTime) / 1_000_000;
        long previousReviewTime = currentFlashcard.getNextReview() - currentFlashcard.getInterval(); // Store the previous next_review time

        flashcardDAO.insertReviewHistory(
                currentFlashcard.getId(),
                quality,
                currentTime,
                previousReviewTime,
                (int) (currentFlashcard.getInterval()), // Interval in seconds
                "normal", // Review type
                answerDuration
        );


        // Update the flashcard after review (this will modify nextReview time)
        updateFlashcardAfterReview(currentFlashcard, quality);

        // Calculate the time difference between the new and old next_review times
        long timePushed = currentFlashcard.getNextReview()  - System.currentTimeMillis();

        // Use the utility method to format the time difference and show a Toast
        String timeDifference = TimeUtils.formatTimeDifference(timePushed);
        Toast.makeText(this, "Next: " + timeDifference, Toast.LENGTH_LONG).show();

        // Update counters based on the time moved and quality score
        if (timePushed > 24 * 60 * 60 * 1000L) { // More than one day
            questionsMovedCount++;
        }

        // Update score based on quality rating
        score += quality;

        // Update UI counters
        updateCounters();

        // Continue to the next flashcard or finish the session
        showNextFlashcard();



    }

    private void updateCounters() {
        int[] counts = flashcardDAO.getPastAndFutureQuestionsCount();
        tvTotalQuestions.setText(String.valueOf(seenFlashcards.size()));
        tvQuestionsMoved.setText(String.valueOf(questionsMovedCount));
        tvPast.setText(String.valueOf(counts[0]));
        tvFuture.setText(String.valueOf(counts[1]));
    }


    // Updated the review algorithm to use faster intervals with seconds-based increments.
    private void updateFlashcardAfterReview(Flashcard flashcard, int quality) {
        int interval = flashcard.getInterval(); // Current interval in seconds
        int repetition = flashcard.getRepetition(); // Current repetition count
        long currentTime = System.currentTimeMillis();
        long lastReviewTime = flashcard.getNextReview() - interval * 1000L; // Calculate when the last review was

        // Handle different quality values and set new interval
        switch (quality) {
            case 0:
                interval = 1; // 0 = 1s
                repetition = 0; // Reset repetition if wrong
                break;
            case 1:
                interval = 10; // 1 = 10s
                repetition = 0; // Reset repetition if wrong
                break;
            case 2:
                interval = 20; // 2 = 20s
                repetition = 0; // Reset repetition if wrong
                break;
            case 3:
                interval = 30; // 3 = 30s
                repetition += 1; // Increment repetition if right
                break;
            case 4:
                interval = 1600; // 4 = last interval * 2
                repetition += 1; // Increment repetition if right
                break;
            case 5:
                // 5 = time lapsed since the last time I saw the question * 2
                long timeLapsed = (currentTime - lastReviewTime) / 1000; // Convert time lapsed to seconds
                interval = (int) (timeLapsed * 2)+3600;
                repetition += 1; // Increment repetition if right
                break;
            default:
                // Fallback for unexpected values (just in case)
                interval = 30;
                repetition = 0; // Reset repetition just in case
                break;
        }

        // Calculate the next review time
        long nextReview = currentTime + interval * 1000L;

        // Update flashcard with the new interval, next review time, and repetition count
        flashcard.setInterval(interval);
        flashcard.setNextReview(nextReview);
        flashcard.setRepetition(repetition); // Save repetition count

        // Save flashcard to the database
        flashcardDAO.updateFlashcard(flashcard);
    }

    private final ActivityResultLauncher<Intent> editFlashcardLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (result.getResultCode() == RESULT_OK) {
                    // Reload the flashcard when returning with a successful result
                    if (currentFlashcard != null) {
                        currentFlashcard = flashcardDAO.getFlashcard(currentFlashcard.getId());
                    }
                }
            }
    );

    private void openEditQuestion() {
        if (currentFlashcard != null) {
            Intent intent = new Intent(this, EditFlashcardActivity.class);
            intent.putExtra("FLASHCARD_ID", currentFlashcard.getId()); // Pass the ID of the flashcard
            editFlashcardLauncher.launch(intent);
        }
    }


    @Override
    protected void onDestroy() {
        flashcardDAO.close();
        super.onDestroy();
    }
}
    ]]>
  </file>
  <file name="TimeUtils.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\TimeUtils.java">
    <[CDATA[
package com.example.flashcardapp.main;

public class TimeUtils {

    // Method to convert milliseconds to dd-hh:mm:ss format
    public static String formatTimeDifference(long timeInMillis) {
        long seconds = timeInMillis / 1000;
        long days = seconds / (24 * 3600);
        seconds %= (24 * 3600);
        long hours = seconds / 3600;
        seconds %= 3600;
        long minutes = seconds / 60;
        seconds %= 60;

        return String.format("%02d\n%02d:%02d:%02d", days, hours, minutes, seconds);
    }
}
    ]]>
  </file>
  <file name="TopicSelectionActivity.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\TopicSelectionActivity.java">
    <[CDATA[
// File: TopicSelectionActivity.java
package com.example.flashcardapp.main;

import android.os.Bundle;
import android.widget.Button;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Topic;

import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import java.util.List;

public class TopicSelectionActivity extends AppCompatActivity {

    private TopicSelectionAdapter adapter;
    private FlashcardDAO flashcardDAO;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_topic_selection);

        flashcardDAO = new FlashcardDAO(this);
        flashcardDAO.open();

        RecyclerView rvTopics = findViewById(R.id.rv_topics);
        Button btnSave = findViewById(R.id.btn_save);

        rvTopics.setLayoutManager(new LinearLayoutManager(this));

        // Load all topics from the database
        List<Topic> allTopics = flashcardDAO.getAllTopics();

        // Initialize the adapter with the topics list
        adapter = new TopicSelectionAdapter(allTopics);
        rvTopics.setAdapter(adapter);

        btnSave.setOnClickListener(v -> {
            saveSelectedTopicsToDatabase(adapter.getSelectedTopics());
            finish(); // Close activity after saving
        });
    }

    private void saveSelectedTopicsToDatabase(List<Topic> topics) {
        for (Topic topic : topics) {
            flashcardDAO.updateTopicSelection(topic.getId(), topic.isSelected());
        }
    }

    @Override
    protected void onDestroy() {
        flashcardDAO.close();
        super.onDestroy();
    }
}
    ]]>
  </file>
  <file name="TopicSelectionAdapter.java" path="C:\Users\Linse\Documents\Programmieren\flashcardapp\app\src\main\java\com\example\flashcardapp\TopicSelectionAdapter.java">
    <[CDATA[
// File: TopicSelectionAdapter.java
package com.example.flashcardapp.main;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;

import com.example.flashcardapp.R;
import com.example.flashcardapp.data.Topic;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;
import java.util.List;

public class TopicSelectionAdapter extends RecyclerView.Adapter<TopicSelectionAdapter.TopicViewHolder> {

    private final List<Topic> topics;

    public TopicSelectionAdapter(List<Topic> topics) {
        this.topics = topics;
    }

    @NonNull
    @Override
    public TopicViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_topic_selection, parent, false);
        return new TopicViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull TopicViewHolder holder, int position) {
        Topic topic = topics.get(position);
        holder.cbTopic.setText(topic.getName());
        holder.cbTopic.setChecked(topic.isSelected());

        // Update selection state on checkbox change
        holder.cbTopic.setOnCheckedChangeListener((buttonView, isChecked) -> topic.setSelected(isChecked));
    }

    @Override
    public int getItemCount() {
        return topics.size();
    }

    public List<Topic> getSelectedTopics() {
        return topics;
    }

    static class TopicViewHolder extends RecyclerView.ViewHolder {
        CheckBox cbTopic;

        public TopicViewHolder(@NonNull View itemView) {
            super(itemView);
            cbTopic = itemView.findViewById(R.id.cb_topic);
        }
    }
}
    ]]>
  </file>
</directory> 
